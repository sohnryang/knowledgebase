# $O(n \lg n)$에 LIS 구하기

## $O(n^2)$ 알고리즘 다시 보기

간단하게 생각하면 $O(n^2)$ 알고리즘을 얻을 수 있다. `dp[i]`를 `i`번째 숫자부터 시작하는 LIS의 길이라고 하면, `dp[i]`은 `dp[i + 1]`, `dp[i + 2]`, ..., `dp[n - 1]`중 LIS를 얻을 수 있는 것들에서 최댓값이다. 이때 각 상태를 계산하는데 $O(n)$이므로, 시간복잡도가 $O(n^2)$이 된다.

## $O(n \lg n)$ 알고리즘

`d[i]`를 길이가 `i`인 모든 LIS에 대해, LIS의 마지막 수의 최솟값이라고 하자. 예를 들어 다음 수열에 대해서

```text
10 20 10 30 20 50
```

`L`은 다음과 같다.

| `i`    | 1    | 2    | 3    | 4    |
| ------ | ---- | ---- | ---- | ---- |
| `L[i]` | 10   | 20   | 30   | 50   |

이때 `d`는 길이가 `i`인 LIS의 마지막 수는 마지막 수보다 항상 작기 때문에 증가하는 배열이다. 원래 수열이 담긴 배열을 `A`라고 하면, `d`에서 `A[i]`보다 작으면서 가장 뒤에 있는 원소를 찾으면 LIS의 길이를 구할 수 있다. 이 아이디어를 나이브하게 구현하면 다음과 같다.

1. `i`에 대해 0부터 `n - 1`까지 반복한다.
   1. `j`에 대해 1부터 `n`까지 반복한다.
      1. `d[j - 1] < a[i] < d[j]`일 때 `d[j]`에 `a[i]`를 저장한다.

이 알고리즘은 $O(n^2)$이지만, 안쪽 반복문 대신 `std::upper_bound`와 같은 이진 탐색을 사용하면 시간 복잡도를 $O(n \lg n)$으로 줄일 수 있다.

### 최적해의 재구성

`d[i]`에 들어가는 수의 `A`에서의 인덱스를 `d_idx[i]`에 저장한다. 다시 말해, `d[j] = A[i]`이면 `d_idx[j] = i`이다. 또한, `p[i]`라는 배열에는 `i`로 끝나는 LIS의 마지막에서 두번째 숫자의 인덱스를 저장해 놓는다.

재구성을 위해서는 LIS의 마지막 숫자의 `A`에서의 인덱스를 `pos`로 두고, `pos = p[A[pos]]`로 업데이트하면서 `A[pos]`를 모으면 된다.