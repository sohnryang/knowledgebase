# $O(n \lg n)$에 LIS 구하기

## $O(n^2)$ 알고리즘 다시 보기

간단하게 생각하면 $O(n^2)$ 알고리즘을 얻을 수 있다. `dp[i]`를 `i`번째 숫자부터 시작하는 LIS의 길이라고 하면, `dp[i]`은 `dp[i + 1]`, `dp[i + 2]`, ..., `dp[n - 1]`중 LIS를 얻을 수 있는 것들에서 최댓값이다. 이때 각 상태를 계산하는데 $O(n)$이므로, 시간복잡도가 $O(n^2)$이 된다.

## $O(n \lg n)$ 알고리즘

`d[i]`를 길이가 `i`인 모든 LIS에 대해, LIS의 마지막 수의 최솟값이라고 하자. 예를 들어 다음 수열에 대해서

```text
10 20 10 30 20 50
```

`L`은 다음과 같다.

| `i`    | 1    | 2    | 3    | 4    |
| ------ | ---- | ---- | ---- | ---- |
| `L[i]` | 10   | 20   | 30   | 50   |

이때 `d`는 길이가 `i`인 LIS의 마지막 수는 마지막 수보다 항상 작기 때문에 증가하는 배열이다. 원래 수열이 담긴 배열을 `A`라고 하면, `d`에서 `A[i]`보다 작으면서 가장 뒤에 있는 원소를 찾으면 LIS의 길이를 구할 수 있다. 이 아이디어를 나이브하게 구현하면 다음과 같다.

1. `i`에 대해 0부터 `n - 1`까지 반복한다.
   1. `j`에 대해 1부터 `n`까지 반복한다.
      1. `d[j - 1] < a[i] < d[j]`일 때 `d[j]`에 `a[i]`를 저장한다.

이 알고리즘은 $O(n^2)$이지만, 안쪽 반복문 대신 `std::upper_bound`와 같은 이진 탐색을 사용하면 시간 복잡도를 $O(n \lg n)$으로 줄일 수 있다.

### 최적해의 재구성

`p`라는 배열을 두고, `d`의 값을 갱신할 때마다 `p[i] = j`라고 둔다. 이때 `p[i]`는 `a[i]`가 얼마나 긴 LIS의 마지막 원소인지를 나타낸다. 예를 들어 `p[3] = 2`라면, `a[3]`은 길이 2인 LIS의 마지막 원소이다.

재구성을 하기 위해서는 다음 알고리즘을 사용한다.

1. `len`을 LIS의 길이 - 1으로 설정한다.
2. `i`에 대해 `n - 1`부터 0까지 반복한다.
   1. 만약 `len`이 0 이하이면 루프를 종료한다.
   2. `p[i] == x`일 때 재구성한 수열의 맨 앞에 `a[i]`를 추가한다.
   3. `len`을 1 감소시킨다.

이 알고리즘이 주목하는 사실은 길이 n인 LIS에, 적절한 숫자를 붙이면 길이 n + 1짜리 LIS를 만들수 있다는 것이다.